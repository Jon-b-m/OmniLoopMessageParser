# OmniLoopMessageParser
python code to parse the messages found in Loop Reports

## April 11, 2020
Add seqNum and CRC16 to DataFrame read from Loop Report.
Refactor some names:
* from command to msg
* from message_type to msg_type
* from raw_value to msg_body (the CRC16 is removed from omnipod messages)

## April 10, 2020
Added parsing of the 0x01 pod responses during initialization and add flag to direct type of results posted (just init vs full analysis).  Have modularized part of the output stream (to terminal and or output file)

ToDo:
* fix the time parsing with the Device Communication log
* add message sequence number to the pod message analysis
* finish the modularization of output

## March 3, 2020
Start modifying code - attempt to keep this always working with documentation not too out of date.  But this is a moving target for a bit.
The messageLog (omnipod only) has been replaced by Device Communication Log.
Go back and completely rewrite some of the early code and clean up other functions to be more modular.

## Origins
Some of the intial work done by Eelke Jager on the Jupyter workbook was copied to my local computer to enable batch processing and easy reprocessing (https://omnikit-lab.herokuapp.com/lab?)

## Current (WIP) Version
Set up a main.py that handles which of the two file formats is found in the file generated by Loop via Issue Report.
With the new persistent log, messages from more than one pod can be found in a single Report.
This is handled (WIP) using analyzeAllPodsInDeviceLog function.
Each group of messages from a single pod is handled using analyzePodMessages.

## Single Pod Analysis

Use an action dictionary that associates messages together.
(WIP - this needs update to handle AB branch and other rileylink_ios changes)

For example, a temporary basal (with current version of code) requires:
* cancel TB (1f02)
* pod status response (1d)
* set new TB (1a16)
* pod status response (1d)

If these 4 do not line up as sequential messages for any TB in the podState dataframe, identified by the index for the associated 1a16 row, that '1a16' index is inserted in an incompleteList for that action.

If they do line up, then the start time (in sec from start of pod) and response time (from 1f02 to final 1d) is tabulated along with the state of the pod - i.e., is it running a scheduled basal (True) or not (False) prior to the initial cancel TB message. All 4 of the indices for each complete action instance are combined into a completedList.

This enables better reporting of various results and enables easier additions of requested analysis tasks.

# How Marion uses the code:

## Updates to output_master_rev3.csv

NOTE - This is left-over and will be updated

Download one Loop Report from Zulip and place in folder for that person; insert _0xFF if there was a FF fault reported (even if the 0x0202 message was not captured)

* python whatIsLastReport.py  # to make sure file is in right place

* python runLastLoopReport.py # to report formatted information to the terminal window

If there is anything off-nominal or interesting, copy and paste that to the zulip window, otherwise, just do a thumbs-up emoji to indicate report was captured.

# Main Code

## main.py :
Input arguments:
* thisPath  : top path where the Loop Reports are filed on local computer
* thisFile  : folderName/reportName  (FolderName is the person's name)
* outFile   : absolute filename for .csv output, output content depends on vFlag
* vFlag
**     : if 0: output analysis to terminal window
**     : if 1: output pod session analysis to outFile
**     : if 2: report init steps to terminal if available
**     : if 3: output init summary to outFile, init steps if too many, skip rest of pod analysis
**     : if 4: report init steps to outFile_init.csv, report podState to outFile_podState.csv

Main routine for reading file and deciding what to do based off report contents

Top Level functions called by main:
* persist_read_file
* analyzePodMessages
* analyzeAllPodsInDeviceLog

## analyzeAllPodsInDeviceLog.py :

Break the pod messages by Pod address, with noPod going to next address
Call analyzePodMessages for each chunk of messages

## analyzePodMessages.py :

Routine for processing and reporting results for a single pod from Loop Report.
Move some of the common stuff to utils

Parses the message logs, prints a report and, if asked, outputs a row to a named csv file.

Top Level functions called by analyzePodMessages:
* generate_table
* parse_info_from_filename
* podStateAnalysis
* checkAction

## messageLogs_functions.py :

Group of functions originally created by Eelke on Jupyter. Subsequently modified slightly with a few new functions added. Generates a pandas dataframe, aka, df, from every message in the log.
WIP - this file is being revised
Includes:
* _parse_filehandle(filehandle):
* _message_dict(data):
* _device_message_dict(data):
* _extract_pod_state(data):
* select_extra_command(raw_value):
* generate_table(df, radio_on_time):
* parse_info_from_filename(filename):
* persist_read_file(filename):
* persist_pod_dict(parsed_content):
* persist_fault_report(parsed_content):
* omnipodP(message):
* otherP(message):
* persist_message(fileType, parsed_content):

## podStateAnalysis.py

This parses every raw message in df. The output from this function includes the podState dataframe, which reports useful information like time stamp (UTC), radio on time, time since start of pod, bool values for immediate_bolus_active, temp_basal_active and scheduled_basal_active, and the last requested values for Bolus and TB.  It also has the message_type and raw_value of the message from the df frame. (Note - I did not put in logic tracking for extended_bolus_active since that is not used by Loop so is always false).

## checkAction.py

This uses the actionDict (from podUtils) to extract typical actions from podState.  (See example at beginning of README.md.) If an action exists in the actionDict, it is grouped into the actionFrame dataframe returned by this function. The indices associated with the pod initialization are also returned, with the pod_progress values used to identify when pod is being initialized.

*     actionColumnNames = ('actionName', 'msgPerAction', 'cumStartSec', \
      'responseTime' , 'SchBasalState', 'incompleteList','completedList' )

## Lower Level functions

* get_file_list.py : given a path, find all the named subpaths with their associated Loop Report.md files, return list sorted from oldest to newest

* utils.py : low level routines used by more than one function

* messagePatternParsing.py : decides which parser to call and if parser doesn't exist yet, returns default msgDict dictionary

The following functions parse the indicated command and return result in a msgDict dictionary:
* parse_1a13.py
* parse_1a16.py
* parse_1a17.py
* parse_1d.py
* parse_1f.py
* parse_01.py
* parse_02.py
* parse_06.py
* parse_0e.py

utils_pd.py : contains various pandas DataFrame specific utilities

utils_pod.py : contains various pod specific utilities:
* getPodProgressMeaning
* getUnitsFromPulses
* getActionDict

* getAnalysisIO.py: switches between Marion's configuration of files for Mac and PC without having to tweak the runLastLoopReport code manually. For anyone pulling this repo to their machine, this should be the only function that requires editing.
